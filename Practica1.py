# -*- coding: utf-8 -*-
"""Práctica 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ujgWsSy820X5bupe1oya5pThNQJVZrV9
"""

import yfinance
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression as RegresionLineal
from sklearn.metrics import mean_squared_error, mean_absolute_error

# Apartado A.
sp500 = yfinance.download("^GSPC", start="2022-01-04", end="2023-09-30") # Descargar datos de la empresa S&P 500
sp500 = sp500.dropna() # Quitar valores nulos de los datos descargados
media = sp500['Close'].mean() # Hacer la media de los datos influyentes
desviacion_tipica = sp500['Close'].std() # Hacer la desviacion tipica de los datos influyentes
# Definir los umbrales de mas/menos 2 desviaciones tipicas
umbral_superior = media + 2 * desviacion_tipica
umbral_inferior = media - 2 * desviacion_tipica
sp500 = sp500[(sp500['Close'] >= umbral_inferior) & (sp500['Close'] <= umbral_superior)] #Eliminar los datos que estan mas alla de los umbrales
varianza = sp500['Close'].var() # Calcular varianza de los datos cerrados
sesgo = sp500['Close'].skew() # Calcular el sesgo de los datos carrados
kurtosis = sp500['Close'].kurtosis() # Calcular la kurtosis
# Imprimir resultados
print("Apartado A.")
print()
print("Resultados estadísticos del S&P 500:")
print(f"Media: {media}")
print(f"Varianza: {varianza}")
print(f"Sesgo: {sesgo}")
print(f"Kurtosis: {kurtosis}")
# Dibujar un histograma del S&P 500
plt.hist(sp500['Close'], bins=20, edgecolor='k')
plt.xlabel('Precio de Cierre (Close)')
plt.ylabel('Frecuencia')
plt.title('Histograma de Precios de Cierre del S&P 500')
plt.show()
print()
print()
print()

# Apartado B.
# Obtener datos históricos del S&P 500 desde el 4 de enero de 2022 hasta el 30 de septiembre de 2023
sp500 = yfinance.download("^GSPC", start="2022-01-04", end="2023-09-30")
# Calcular las rentabilidades diarias (rt) a partir de los precios de cierre
sp500['Rendimiento'] = sp500['Adj Close'].pct_change() * 100  # Multiplicamos por 100 para expresar en porcentaje
# Eliminar observaciones inexistentes (valores nulos)
sp500 = sp500.dropna()
# Crear la matriz de variables independientes (x) y el vector de variable dependiente (y)
x = []
y = []
for i in range(5, len(sp500)):
    x.append(sp500.iloc[i-5:i]['Rendimiento'].values)
    y.append(sp500.iloc[i]['Rendimiento'])
# Convertir listas en arrays de NumPy
x = np.array(x)
y = np.array(y)
# Crear y ajustar el modelo de regresión lineal múltiple
modelo = RegresionLineal()
modelo.fit(x, y)
# Realizar predicciones dentro de la muestra
y_pred = modelo.predict(x)
# Calcular métricas de evaluación
mse = mean_squared_error(y, y_pred) # Calcular error cuadrático medio
mae = mean_absolute_error(y, y_pred) # Calcular error absoluto medio
mape = np.mean(np.abs((y - y_pred) / y)) * 100 # Calcular error porcentual albsoluto medio
# Modelo de paseo aleatorio (predicción para el próximo período igual al valor actual)
y_paseo_aleatorio = []
for i in range(len(y)):
  y_paseo_aleatorio.append(0)
# Imprimir las métricas de evaluación
print("Apartado B.")
print()
print("Métricas del Modelo:")
print("MSE (Error Cuadrático Medio):", mse)
print("MAE (Error Absoluto Medio):", mae)
print("MAPE (Error Porcentual Absoluto Medio):", mape)

print()

print("Métricas del Modelo de Paseo Aleatorio:")
print("MSE (Error Cuadrático Medio):", mse_paseo_aleatorio)
print("MAE (Error Absoluto Medio):", mae_paseo_aleatorio)
print("MAPE (Error Porcentual Absoluto Medio):", mape_paseo_aleatorio)

# Apartado C.
# Obtener datos históricos del S&P 500 desde el 4 de enero de 2022 hasta el 30 de septiembre de 2023
sp500 = yfinance.download("^GSPC", start="2022-01-04", end="2023-09-30")
# Calcular las rentabilidades diarias (rt) a partir de los precios de cierre
sp500['Rendimiento'] = sp500['Adj Close'].pct_change() * 100  # Multiplicamos por 100 para expresar en porcentaje
# Eliminar observaciones inexistentes (valores nulos)
sp500 = sp500.dropna()
# Crear la matriz de variables independientes (x) y el vector de variable dependiente (y)
x = []
y = []

for i in range(30, len(sp500)):
    x.append(sp500.iloc[i-30:i]['Rendimiento'].values)
    y.append(sp500.iloc[i]['Rendimiento'])
# Convertir listas en arrays de NumPy
x = np.array(x)
y = np.array(y)
# Crear y ajustar el modelo de regresión lineal múltiple
modelo = RegresionLineal()
modelo.fit(x, y)
# Realizar predicciones dentro de la muestra
y_pred = modelo.predict(x)
# Imprimir las métricas de evaluación para cada iteración
print("Apartado C.")
print()
lista_mses=[]
print(type(lista_mses))
lista_maes=[]
lista_mapes=[]
for i in range(len(y)):
    mse = mean_squared_error([y[i]], [y_pred[i]]) # Calcular error cuadrático medio
    mae = mean_absolute_error([y[i]], [y_pred[i]]) # Calcular error absoluto medio
    mape = np.abs((y[i] - y_pred[i]) / y[i]) * 100 # Calcular error porcentual absoluto medio

    lista_mses.append(mse)
    lista_maes.append(mae)
    lista_mapes.append(mape)

    mse_acumulado=0
    mae_acumulado=0
    mape_acumulado=0

    for i in range(len(lista_mses)):
      mse_acumulado = mse_acumulado+lista_mses[i]
      mae_acumulado = mae_acumulado+lista_maes[i]
      mape_acumulado = mape_acumulado+lista_mapes[i]

    mse_acumulado = mse_acumulado/len(lista_mses)
    mae_acumulado = mae_acumulado/len(lista_maes)
    mape_acumulado = mape_acumulado/len(lista_mapes)

    print(f"Iteración {i + 1}:")
    print()
    print("Metricas de evaluacion sólo para esta iteración:")
    print("MSE (Error Cuadrático Medio):", mse)
    print("MAE (Error Absoluto Medio):", mae)
    print("MAPE (Error Porcentual Absoluto Medio):", mape)
    print()
    print("Metricas de evaluacion acumuladas hasta esta iteración:")
    print("MSE (Error Cuadrático Medio):", mse_acumulado)
    print("MAE (Error Absoluto Medio):", mae_acumulado)
    print("MAPE (Error Porcentual Absoluto Medio):", mape_acumulado)
    print()
# Calcular métricas de evaluación para el modelo
mse_modelo = mean_squared_error(y, y_pred) # Calcular error cuadrático medio
mae_modelo = mean_absolute_error(y, y_pred) # Calcular error absoluto medio
# Calcular MAPE (Error Porcentual Absoluto Medio)
mape_modelo = np.mean(np.abs((y - y_pred) / y)) * 100
# Modelo de paseo aleatorio (predicción para el próximo período igual al valor actual)
y_paseo_aleatorio = y[:-1]
# Calcular métricas de evaluación para el modelo de paseo aleatorio
mse_paseo_aleatorio = mean_squared_error(y[1:], y_paseo_aleatorio) # Calcular error cuadrático medio
mae_paseo_aleatorio = mean_absolute_error(y[1:], y_paseo_aleatorio) # Calcular error absoluto medio
mape_paseo_aleatorio = np.mean(np.abs((y[1:] - y_paseo_aleatorio) / y[1:])) * 100 # Calcular MAPE
# Imprimir las métricas de evaluación para comparar
print("Métricas del Modelo:")
print("MSE (Error Cuadrático Medio):", mse_modelo)
print("MAE (Error Absoluto Medio):", mae_modelo)
print("MAPE (Error Porcentual Absoluto Medio):", mape_modelo)

print()

print("Métricas del Modelo de Paseo Aleatorio:")
print("MSE (Error Cuadrático Medio):", mse_paseo_aleatorio)
print("MAE (Error Absoluto Medio):", mae_paseo_aleatorio)
print("MAPE (Error Porcentual Absoluto Medio):", mape_paseo_aleatorio)

#Apartado D.
# Obtener datos históricos del S&P 500 desde el 4 de enero de 2022 hasta el 30 de septiembre de 2023
sp500 = yfinance.download("^GSPC", start="2022-01-04", end="2023-09-30")
# Calcular las rentabilidades diarias (rt) a partir de los precios de cierre
sp500['Rendimiento'] = sp500['Adj Close'].pct_change()
# Eliminar observaciones inexistentes (valores nulos)
sp500 = sp500.dropna()
# Calcular rentabilidad
print("Apartado D.")
print()
rentabilidad=0
for i in range(len(sp500)-30):
  if(y_pred[i]>0):
    rentabilidad+=sp500.iloc[i+30]['Rendimiento']
# Imprimir resultado
print("Rentabilidad de la inversion:", rentabilidad)